// ============================================================================
// 极坐标纹理效果示例
// 参考：https://www.vertexfragment.com/ramblings/polar-coordinates/
// ============================================================================

#include <string>
#include <memory>
#include <iostream>
#include "utils/VertexBuffer.h"
#include "utils/Window.h"
#include "utils/Shader.h"
#include "utils/VertexArray.h"
#include "utils/FPS.h"

/**
 * GlslPolarTex 类
 * 
 * 这个类封装了整个极坐标纹理效果的应用
 * 使用 RAII（Resource Acquisition Is Initialization）模式管理资源
 */
class GlslPolarTex {
public:
    /**
     * 构造函数
     * 
     * 作用：
     * - 创建窗口
     * - 加载着色器
     * - 初始化 OpenGL 对象
     */
    GlslPolarTex(unsigned int width, unsigned int height, const std::string& title)
        // 成员初始化列表：在构造函数体执行前初始化成员变量
        : window(std::make_unique<Window>(width, height, title))
        , shader(std::make_unique<Shader>(
            "shaders/01_shaders/1_2_5_GlslPolarTex.vert", 
            "shaders/01_shaders/1_2_5_GlslPolarTex.frag"))
        , vao(std::make_unique<VertexArray>())
        , fps(std::make_unique<FPS>(60))  // 限制在 60 FPS
    {
        init();  // 调用初始化函数
    }
    
    /**
     * 主循环函数
     * 
     * 这是程序的"心脏"，不断循环执行：
     * 1. 更新时间
     * 2. 处理输入
     * 3. 更新参数
     * 4. 渲染画面
     */
    void run() {
        float time = 0.0f;  // 累积时间（秒）
        
        // ====================================================================
        // 效果参数配置
        // 
        // 这些参数控制效果的外观和行为
        // 可以实时修改这些值来调整效果！
        // ====================================================================
        
        // --------------------------------------------------------------------
        // 时间参数
        // --------------------------------------------------------------------
        float fadeDuration = 3.0f;     
        // 扩展周期（秒）
        // - 一个完整的"扩散+消失"循环需要多长时间
        // - 值越大，动画越慢
        // - 推荐范围：1.0 ~ 5.0
        
        float movementSpeed = 0.3f;    
        // 向外扩展速度
        // - 控制噪声纹理向外移动的速度
        // - 值越大，扩散越快
        // - 推荐范围：0.1 ~ 1.0
        
        float rotationSpeed = 0.1f;
        // 旋转速度
        // - 产生漩涡/螺旋效果
        // - 正值顺时针，负值逆时针
        // - 推荐范围：-0.5 ~ 0.5
        
        // --------------------------------------------------------------------
        // 视觉参数
        // --------------------------------------------------------------------
        float smoothness = 2.0f;       
        // 噪声平滑度/对比度
        // - 控制噪声的明暗对比
        // - 值越大，对比度越高，图案越清晰
        // - 推荐范围：1.0 ~ 4.0
        
        float ringSoftness = 8.0f;     
        // 环边缘柔和度
        // - 控制环边界的锐利程度
        // - 值越大，边缘越锐利
        // - 值越小，边缘越模糊
        // - 推荐范围：2.0 ~ 16.0
        
        float finalStrength = 3.0f;    
        // 最终强度
        // - 控制整体对比度和亮度
        // - 影响溶解效果的锐利度
        // - 推荐范围：1.0 ~ 5.0
        
        // --------------------------------------------------------------------
        // 环尺寸参数
        // 格式：{最小半径, 最大半径, 最大厚度, 最小厚度}
        // --------------------------------------------------------------------
        float ringDimensions[4] = {
            0.0f,   // 最小半径：环从中心开始
            0.5f,   // 最大半径：环扩散到屏幕一半
            0.2f,   // 最大厚度：开始时环很厚
            0.05f   // 最小厚度：结束时环变薄
        };
        
        // 理解环的行为：
        // - 随着时间推移，半径从 0.0 增长到 0.5
        // - 同时，厚度从 0.2 减小到 0.05
        // - 这创造了"向外扩散并变薄"的效果
        
        // --------------------------------------------------------------------
        // 颜色配置（HDR - High Dynamic Range）
        // 格式：{R, G, B, A}，值可以大于 1.0！
        // --------------------------------------------------------------------
        float tint[4] = {0.3f, 1.5f, 2.0f, 1.0f};
        
        // 什么是 HDR？
        // - 传统颜色值范围：0.0 ~ 1.0
        // - HDR 允许值 > 1.0，配合 Bloom 后期处理产生发光效果
        // - 类似相机的"过曝"，让亮部看起来"发光"
        
        // 预设配置：
        // 青色魔法（当前）：{0.3, 1.5, 2.0, 1.0}
        // 水环效果：       {0.5, 0.8, 1.0, 0.3}  // 更柔和
        // 火焰效果：       {2.0, 1.0, 0.3, 1.0}  // 橙红色
        // 能量波：         {1.0, 2.0, 1.0, 1.0}  // 绿色
        // 纯白发光：       {3.0, 3.0, 3.0, 1.0}  // 强烈发光
        
        // ====================================================================
        // 主循环
        // ====================================================================
        while(!window->shouldClose()) {
            
            // ----------------------------------------------------------------
            // 1. 时间更新
            // ----------------------------------------------------------------
            fps->update();  // 更新 FPS 计数器和 deltaTime
            window->pollEvents();  // 处理窗口事件（键盘、鼠标等）
            
            // 累积时间（与帧率无关）
            float deltaTime = fps->getDeltaTime();  // 上一帧耗时（秒）
            time += deltaTime;
            
            // ----------------------------------------------------------------
            // 2. 清屏
            // ----------------------------------------------------------------
            glClearColor(0.0, 0.0, 0.0, 1.0);  // 黑色背景
            glClear(GL_COLOR_BUFFER_BIT);      // 清除颜色缓冲
            
            // ----------------------------------------------------------------
            // 3. 设置 Shader Uniforms
            // 
            // Uniform 是什么？
            // - 从 CPU 传递给 GPU 的参数
            // - 所有像素（片段）共享同一个值
            // - 每帧可以修改
            // ----------------------------------------------------------------
            shader->use();  // 激活着色器程序
            
            // 设置浮点数 uniforms
            shader->setFloat("uTime", time);
            shader->setFloat("uFadeDuration", fadeDuration);
            shader->setFloat("uMovementSpeed", movementSpeed);
            shader->setFloat("uRotationSpeed", rotationSpeed);
            shader->setFloat("uSmoothness", smoothness);
            shader->setFloat("uRingSoftness", ringSoftness);
            shader->setFloat("uFinalStrength", finalStrength);
            
            // 设置 vec4 uniforms（四维向量）
            // glGetUniformLocation：获取 uniform 变量在 shader 中的位置
            // glUniform4f：设置四个浮点数值
            glUniform4f(
                glGetUniformLocation(shader->ID, "uRingDimensions"), 
                ringDimensions[0],  // x: 最小半径
                ringDimensions[1],  // y: 最大半径
                ringDimensions[2],  // z: 最大厚度
                ringDimensions[3]   // w: 最小厚度
            );
            
            glUniform4f(
                glGetUniformLocation(shader->ID, "uTint"), 
                tint[0],  // r: 红色分量
                tint[1],  // g: 绿色分量
                tint[2],  // b: 蓝色分量
                tint[3]   // a: alpha（透明度）
            );
            
            // ----------------------------------------------------------------
            // 4. 绘制
            // ----------------------------------------------------------------
            vao->bind();  // 绑定 VAO（顶点数组对象）
            
            // glDrawElements：使用索引缓冲绘制
            // - GL_TRIANGLES：绘制三角形
            // - 6：索引数量（2个三角形 = 6个索引）
            // - GL_UNSIGNED_INT：索引类型
            // - 0：索引缓冲偏移量
            glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0);
            
            // ----------------------------------------------------------------
            // 5. 交换缓冲
            // ----------------------------------------------------------------
            window->swapBuffer();  // 显示渲染结果
            
            // 双缓冲是什么？
            // - 前缓冲：当前显示在屏幕上的
            // - 后缓冲：正在绘制的
            // - 交换：瞬间切换，避免闪烁
        }
    }

private:
    // 成员变量（使用智能指针自动管理内存）
    std::unique_ptr<Window> window;        // 窗口对象
    std::unique_ptr<Shader> shader;        // 着色器程序
    std::unique_ptr<VertexArray> vao;      // 顶点数组对象
    std::unique_ptr<FPS> fps;              // FPS 管理器
    
    /**
     * 初始化函数
     * 
     * 作用：
     * - 创建一个全屏四边形（两个三角形）
     * - 设置顶点属性
     * - 启用混合（透明度）
     */
    void init() {
        
        // ====================================================================
        // 顶点数据
        // ====================================================================
        
        // 定义四个顶点（全屏四边形的四个角）
        // 格式：{x, y, z}
        // NDC 坐标（Normalized Device Coordinates）：-1 到 1
        float vertices[] = {
            // 左上角
            -1.0f,  1.0f, 0.0f,  // 顶点 0
            // 左下角
            -1.0f, -1.0f, 0.0f,  // 顶点 1
            // 右下角
             1.0f, -1.0f, 0.0f,  // 顶点 2
            // 右上角
             1.0f,  1.0f, 0.0f   // 顶点 3
        };
        
        // 图示（从上往下看）：
        //   0 -------- 3
        //   |          |
        //   |          |
        //   1 -------- 2

        // ====================================================================
        // 索引数据
        // ====================================================================
        
        // 定义两个三角形来组成四边形
        // 为什么用索引？
        // - 避免顶点重复
        // - 节省内存和传输带宽
        unsigned int indices[] = {
            0, 1, 2,  // 第一个三角形（左下）
            0, 2, 3   // 第二个三角形（右上）
        };
        
        // 图示：
        //   0 -------- 3
        //   |╲   [2] ╱|
        //   | ╲     ╱ |
        //   |  [1] ╱  |
        //   | ╱   ╱   |
        //   |╱   ╱    |
        //   1 -------- 2

        // ====================================================================
        // 创建并设置 OpenGL 对象
        // ====================================================================
        
        vao->bind();  // 绑定 VAO（之后的操作会被记录到这个 VAO）
        
        // -------------------------------------------------------------------
        // VBO（Vertex Buffer Object）：存储顶点数据
        // -------------------------------------------------------------------
        VertexBuffer vbo(GL_ARRAY_BUFFER);
        vbo.upload(vertices, sizeof(vertices) / sizeof(float));
        
        // 什么是 VBO？
        // - 在 GPU 显存中分配的缓冲区
        // - 存储顶点位置、颜色、UV 等数据
        // - 比每帧从 CPU 传输数据快得多
        
        // -------------------------------------------------------------------
        // 顶点属性配置
        // -------------------------------------------------------------------
        std::vector<VertexAttribute> attrs {
            VertexAttribute{
                0,                      // location：对应 shader 中的 layout(location = 0)
                3,                      // size：每个顶点 3 个分量（x, y, z）
                AttributeType::Float,   // type：数据类型是浮点数
                false,                  // normalized：不需要归一化
            }
        };
        vao->addVertexBuffer(vbo, attrs);
        
        // 这告诉 OpenGL：
        // - 顶点位置数据在 location 0
        // - 每个位置有 3 个浮点数
        // - 对应 shader 中的 "layout(location = 0) in vec3 aPos;"

        // -------------------------------------------------------------------
        // EBO（Element Buffer Object）：存储索引数据
        // -------------------------------------------------------------------
        VertexBuffer ebo(GL_ELEMENT_ARRAY_BUFFER);
        ebo.upload(indices, sizeof(indices) / sizeof(unsigned int));
        vao->setIndexBuffer(ebo);
        
        // 什么是 EBO？
        // - 存储顶点索引的缓冲区
        // - 允许顶点重用，减少数据量
        // - 这里用 6 个索引定义 2 个三角形（共用 4 个顶点）
        
        // -------------------------------------------------------------------
        // 解绑
        // -------------------------------------------------------------------
        vao->unbind();   // 解绑 VAO
        vbo.unbind();    // 解绑 VBO
        ebo.unbind();    // 解绑 EBO
        
        // 为什么要解绑？
        // - 防止后续操作意外修改这些对象
        // - 养成良好的 OpenGL 编程习惯
        
        // -------------------------------------------------------------------
        // 启用混合（Blending）
        // -------------------------------------------------------------------
        glEnable(GL_BLEND);
        
        // 什么是混合？
        // - 控制透明和半透明效果
        // - 将新颜色与已有颜色混合
        
        glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
        
        // 混合公式：
        // 最终颜色 = 源颜色 × 源Alpha + 目标颜色 × (1 - 源Alpha)
        // 
        // 例如：
        // - 源 alpha = 1.0（完全不透明）→ 完全显示源颜色
        // - 源 alpha = 0.5（半透明）→ 源和目标各占 50%
        // - 源 alpha = 0.0（完全透明）→ 完全显示目标颜色
        
        std::cout << "==============================================\n";
        std::cout << "极坐标纹理效果\n";
        std::cout << "==============================================\n";
        std::cout << "按 ESC 退出\n";
        std::cout << "==============================================\n";
        std::cout << "效果说明：\n";
        std::cout << "- 从中心向外扩散的魔法环\n";
        std::cout << "- 使用极坐标采样噪声纹理\n";
        std::cout << "- 带旋转和溶解效果\n";
        std::cout << "==============================================\n";
    }
};

// ============================================================================
// 主函数入口
// ============================================================================
int main() {
    try {
        // 创建应用实例
        // 参数：窗口宽度、高度、标题
        GlslPolarTex app(800, 600, "Polar Coordinates Texture Effect");
        
        // 运行主循环
        app.run();
        
    } catch (const std::exception& e) {
        // 捕获并显示错误
        std::cerr << "错误: " << e.what() << std::endl;
        return -1;
    }
    
    return 0;
}

